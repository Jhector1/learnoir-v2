// prisma/seed/_genPracticeCatalog.ts
import fs from "node:fs";
import path from "node:path";

// ✅ seed sources of truth
import { PY_SECTIONS } from "./data/subjects/python/sections";
import { PY_SUBJECT_SLUG as PY_SUBJECT } from "./data/subjects/python/constants";

import { LA_SECTIONS } from "./data/subjects/linear-algebra/sections";
import { LA_SUBJECT_SLUG as LA_SUBJECT } from "./data/subjects/linear-algebra/constants";

import { HC_SECTIONS } from "./data/subjects/haitian-creole/sections";
import { HC_SUBJECT_SLUG as HC_SUBJECT } from "./data/subjects/haitian-creole/constants";

import { AI_SECTIONS } from "./data/subjects/ai/sections";
import { AI_SUBJECT_SLUG as AI_SUBJECT } from "./data/subjects/ai/constants";

type GenModule = {
  moduleSlug: string;
  sectionSlug: string;
  sectionTitle: string;
  sectionOrder: number;
  genKey: string;
  prefix: string;
  topicIds: string[];
  topics: Record<string, string>; // id -> "prefix.id"
};

type GenSubject = {
  subjectSlug: string;
  modulesBySlug: Record<string, GenModule>;
};

type GenCatalog = Record<string, GenSubject>;

// ✅ IMPORTANT: match "as const" (readonly arrays) so `satisfies` won't fail.
const GENERATED_SHAPE_TS = `Record<string, {
  subjectSlug: string;
  modulesBySlug: Record<string, {
    moduleSlug: string;
    sectionSlug: string;
    sectionTitle: string;
    sectionOrder: number;
    genKey: string;
    prefix: string;
    topicIds: readonly string[];
    topics: Record<string, string>;
  }>;
}>`;

function buildSubject(subjectSlug: string, sections: any[]): GenSubject {
  const modulesBySlug: Record<string, GenModule> = {};

  for (const s of sections) {
    const moduleSlug = String(s.moduleSlug);
    const prefix = String(s.prefix);
    const genKey = String(s.genKey);

    const sectionSlug = String(s.section?.slug ?? "");
    const sectionTitle = String(s.section?.title ?? "");
    const sectionOrder = Number(s.section?.order ?? 0);

    const topicIds: string[] = Array.isArray(s.topics)
        ? s.topics.map((t: any) => String(t.id))
        : [];

    const topics: Record<string, string> = {};
    for (const id of topicIds) topics[id] = `${prefix}.${id}`;

    modulesBySlug[moduleSlug] = {
      moduleSlug,
      sectionSlug,
      sectionTitle,
      sectionOrder,
      genKey,
      prefix,
      topicIds,
      topics,
    };
  }

  return { subjectSlug, modulesBySlug };
}

/**
 * Generates a tiny UI-safe catalog into:
 *   src/lib/practice/catalog/generatedCatalog.ts
 */
export async function genPracticeCatalog() {
  const catalog: GenCatalog = {
    [PY_SUBJECT]: buildSubject(PY_SUBJECT, PY_SECTIONS as any),
    [LA_SUBJECT]: buildSubject(LA_SUBJECT, LA_SECTIONS as any),
    [HC_SUBJECT]: buildSubject(HC_SUBJECT, HC_SECTIONS as any),
    [AI_SUBJECT]: buildSubject(AI_SUBJECT, AI_SECTIONS as any),
  };

  const outDir = path.join(process.cwd(), "src/lib/practice/catalog");
  const outFile = path.join(outDir, "generatedCatalog.ts");

  if (!fs.existsSync(outDir)) fs.mkdirSync(outDir, { recursive: true });

  const banner = `/**
 * AUTO-GENERATED FILE — DO NOT EDIT
 * Generated by prisma/seed/_genPracticeCatalog.ts
 */
`;

  // ✅ CRITICAL: keep `as const` on SAME LINE (no newline before `as`)
  const json = JSON.stringify(catalog, null, 2);

  const content =
      banner +
      `export type GeneratedCatalogShape = ${GENERATED_SHAPE_TS};\n` +
      `export const GENERATED_CATALOG = ${json} as const satisfies GeneratedCatalogShape;\n` +
      `export type GeneratedCatalog = typeof GENERATED_CATALOG;\n`;

  fs.writeFileSync(outFile, content, "utf8");
}

// ✅ ALSO export default (prevents import mismatch errors)
export default genPracticeCatalog;